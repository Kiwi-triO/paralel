//Задание 6. То же самое, но с попыткой установить блокировку, и,
//если секция уже заблокирована, с печатью ожидающими потоками с 
//интервалом в 1 секунду сообщения о том, что секция блокирована.
//Использовать функцию omp_test_lock.

//Блокировка в OpenMP — это механизм синхронизации, который позволяет контролировать доступ к общим ресурсам 
//в многопоточных программах. Требуется в частности для предотвращения race condition

#include <iostream>
#include <omp.h>
#include <windows.h> 
#include <locale.h>
using namespace std;

int main(int argc, char* argv[])
{
	setlocale(LC_ALL, ".ACP");

	// Инициализация блокировки
	omp_lock_t my_lock;
	omp_init_lock(&my_lock);

	// Создание параллельной области
#pragma omp parallel num_threads(4)
	{
		int thread_id = omp_get_thread_num(); // Получение ID текущего потока

		// Попытка установить блокировку
		while (omp_test_lock(&my_lock) == 0) {
			// Если блокировка не удалась, выводим сообщение и ждем 1 секунду
			cout << "Поток " << thread_id << ": секция заблокирована, ожидаю..." << endl;
			Sleep(1000); // Задержка в 1 секунду
		}

		// Критическая секция (блокировка установлена)
		cout << "Поток " << thread_id << ": начал работу в критической секции" << endl;
		Sleep(2000); // Имитация вычислений (2 секунды)
		cout << "Поток " << thread_id << ": завершил работу в критической секции" << endl;

		// Снятие блокировки
		omp_unset_lock(&my_lock);
	}

	// Уничтожение блокировки
	omp_destroy_lock(&my_lock);
}